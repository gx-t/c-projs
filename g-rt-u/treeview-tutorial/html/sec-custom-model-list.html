<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Example: A Simple Custom List Model</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="GTK+ 2.0 Tree View Tutorial"
HREF="treeview-tutorial.html"><LINK
REL="UP"
TITLE="Writing Custom Models"
HREF="sec-custom-models.html"><LINK
REL="PREVIOUS"
TITLE="What Does Writing a Custom Model Involve?"
HREF="sec-custom-models-what.html"><LINK
REL="NEXT"
TITLE="From a List to a Tree"
HREF="sec-custom-model-tree.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./treeview-tutorial.css"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="95%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GTK+ 2.0 Tree View Tutorial</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sec-custom-models-what.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 11. Writing Custom Models</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sec-custom-model-tree.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="95%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="sec-custom-model-list"
>11.3. Example: A Simple Custom List Model</A
></H1
><P
>&#13;What follows is the outline for a simple custom list model. You can find the complete source
code for this model <A
HREF="sec-custom-model-code.html"
>below</A
>. The beginning
of the code might look a bit scary, but you can just skip most of the GObject and GType
stuff and proceed to the heart of the custom list, ie. the implementation of the
tree model functions.
</P
><P
>&#13;Our list model is represented by a simple list of records, where each row corresponds to a
<TT
CLASS="literal"
>CustomRecord</TT
> structure which keeps track of the data we are interested in.
For now, we only want to keep track of persons' names and years of birth (usually this would not really
justify a custom model, but this is still just an example). It is trivial to extend
the model to deal with additional fields in the <TT
CLASS="literal"
>CustomRecord</TT
> structure.
</P
><P
>&#13;Within the model, more precisely: the <TT
CLASS="literal"
>CustomList</TT
> structure, the list is
stored as a pointer array, which not only provides fast access to the n-th record in the list,
but also comes in handy later on when we add sorting. Apart from that, any other kind of
list-specific data would go in this structure as well (the active sort column, for example, or
hash tables to speed up searching for a specific row, etc.).
</P
><P
>&#13;Each row in our list is represented by a <TT
CLASS="literal"
>CustomRecord</TT
> structure. You can
store whatever other data you need in that structure. How you make row data available is up
to you. Either you export it via the tree model interface using the
<A
HREF="http://developer.gnome.org/doc/API/2.0/gobject/gobject-Standard-Parameter-and-Value-Types.html"
TARGET="_top"
>GValue system</A
>,
so that you can use <TT
CLASS="literal"
>gtk_tree_model_get</TT
> to retrieve your data, or you
provide custom model-specific functions to retrieve data, for example <TT
CLASS="literal"
>custom_list_get_name</TT
>,
taking a tree iter or a tree path as argument. Of course you can also do both.
</P
><P
>&#13;Furthermore, you will need to provide your own functions to add rows, remove rows, and
set or modify row data, and you need to let the view and others know whenever something
changes in your model by emitting the appropriate signals via the provided tree model
functions.
</P
><P
>&#13;Some thought should go into how exactly you fill the
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#GtkTreeIter"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>GtkTreeIter</TT
> fields</A
> of the tree iters used by
your model. You have three pointer fields at your disposal. These should be filled
so that you can easily identify the row given the iter, and should also facilitate
access to the next row and the parent row (if any). If your model advertises to
have persistent iters, you need to make sure that the content of your iters is
perfectly valid even if the user stores it somewhere for later use and the model
gets changed or reordered. The 'stamp' field of a tree iter should be filled by
a random model-instance-specific integer that was assigned to the model when it
was created. This way you can catch iters that do not belong to your model.
If your model does not have persistent iters, then you should change the model's
stamp whenever the model changes, so that you can catch invalid iters that get
passed to your functions (note: in the code below we do not check the stamp
of the iters in order to save a couple of lines of code to print here).
</P
><P
>&#13;In our specific example, we simply store a pointer to a row's
<TT
CLASS="literal"
>CustomRecord</TT
> structure in our model's tree iters,
which is valid as long as the row exists. Additionally we store the
position of a row within the list in the <TT
CLASS="literal"
>CustomRecord</TT
>
as well, which is not only intuitive, but is also useful later on
when we resort the list.
</P
><P
>&#13;If you want to store an integer value in an iter's fields, you should
use GLib's <TT
CLASS="literal"
>GINT_TO_POINTER</TT
> and
<TT
CLASS="literal"
>GPOINTER_TO_INT</TT
> macros for that.
</P
><P
>&#13;Let's look at the code sections in a bit more detail:
</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sec-custom-model-list-header"
>11.3.1. custom-list.h</A
></H2
><P
>&#13;The <A
HREF="sec-custom-model-code.html#sec-custom-model-code-header"
>header file</A
> for our
custom list model defines some standard type casts and type check macros,
our <TT
CLASS="literal"
>CustomRecord</TT
> structure, our <TT
CLASS="literal"
>CustomList</TT
>
structure, and some enums for the model columns we are exporting.
</P
><P
>The <TT
CLASS="literal"
>CustomRecord</TT
> structure represents one row, while
the <TT
CLASS="literal"
>CustomList</TT
> structure contains all list-specific data.
You can add additional fields to both structures without problems. For example,
you might need a function that quickly looks up rows given the name or year
of birth, for which additional hashtables or so might come in handy
(which you would need to keep up to date as you insert, modify or remove
rows of course).
</P
><P
>&#13;The only function you must export is <TT
CLASS="literal"
>custom_list_get_type</TT
>,
as it is used by the type check and type cast macros that are also defined
in the header file. Additionally, we want to export a function to create one
instance of our custom model, and a function that adds some rows. You will
probably add more custom model-specific functions to modify the model as you
extend it to suit your needs.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sec-custom-model-list-body"
>11.3.2. custom-list.c</A
></H2
><P
>&#13;Firstly, we need some boilerplate code to register our custom model
with the GObject type system. You can skip this section and proceed to the
tree model implementation.
</P
><P
>&#13;Functions of interested in this section are <TT
CLASS="literal"
>custom_list_init</TT
> and
<TT
CLASS="literal"
>custom_list_get_type</TT
>. In <TT
CLASS="literal"
>custom_list_init</TT
> we
define what data type our exported model columns have, and how many columns we export.
Towards the end of <TT
CLASS="literal"
>custom_list_get_type</TT
> we register the
<TT
CLASS="literal"
>GtkTreeModel</TT
> interface with our custom model object. This is where
we can also register additional interfaces (e.g. <TT
CLASS="literal"
>GtkTreeSortable</TT
>
or one of the Drag'n'Drop interfaces) that we want to implement.
</P
><P
>&#13;In <TT
CLASS="literal"
>custom_list_tree_model_init</TT
> we override those tree model functions
that we need to implement with our own functions. If it is beneficial for your model to
know which rows are currently displayed in the tree view (for example for caching), you
might want to override the <TT
CLASS="literal"
>ref_node</TT
> and <TT
CLASS="literal"
>unref_node</TT
>
functions as well.
</P
><P
>&#13;Let's have a look at the heart of the object type registration:
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;GType
custom_list_get_type (void)
{
  static GType custom_list_type = 0;

  if (custom_list_type)
    return custom_list_type;

  /* Some boilerplate type registration stuff */
  if (1)
  {
    static const GTypeInfo custom_list_info =
    {
      sizeof (CustomListClass),
      NULL,                                         /* base_init */
      NULL,                                         /* base_finalize */
      (GClassInitFunc) custom_list_class_init,
      NULL,                                         /* class finalize */
      NULL,                                         /* class_data */
      sizeof (CustomList),
      0,                                           /* n_preallocs */
      (GInstanceInitFunc) custom_list_init
    };

    custom_list_type = g_type_register_static (G_TYPE_OBJECT, "CustomList",
                                               &#38;custom_list_info, (GTypeFlags)0);
  }

  /* Here we register our GtkTreeModel interface with the type system */
  if (1)
  {
    static const GInterfaceInfo tree_model_info =
    {
      (GInterfaceInitFunc) custom_list_tree_model_init,
      NULL,
      NULL
    };

    g_type_add_interface_static (custom_list_type, GTK_TYPE_TREE_MODEL, &#38;tree_model_info);
  }

  return custom_list_type;
}

</PRE
></TD
></TR
></TABLE
><P
>&#13;Here we just return the type assigned to our custom list by the type system
if we have already registered it. If not, we register it and save the type.
Of the three callbacks that we pass to the type system, only two are of
immediate interest to us, namely <TT
CLASS="literal"
>custom_list_tree_model_init</TT
>
and <TT
CLASS="literal"
>custom_list_init</TT
>.
</P
><P
>&#13;In <TT
CLASS="literal"
>custom_list_tree_model_init</TT
> we fill the tree model
interface structure with pointers to our own functions (at least the ones
we implement):
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;static void
custom_list_tree_model_init (GtkTreeModelIface *iface)
{
  /* Here we override the GtkTreeModel
   *  interface functions that we implement */
  iface-&#62;get_flags       = custom_list_get_flags;
  iface-&#62;get_n_columns   = custom_list_get_n_columns;
  iface-&#62;get_column_type = custom_list_get_column_type;
  iface-&#62;get_iter        = custom_list_get_iter;
  iface-&#62;get_path        = custom_list_get_path;
  iface-&#62;get_value       = custom_list_get_value;
  iface-&#62;iter_next       = custom_list_iter_next;
  iface-&#62;iter_children   = custom_list_iter_children;
  iface-&#62;iter_has_child  = custom_list_iter_has_child;
  iface-&#62;iter_n_children = custom_list_iter_n_children;
  iface-&#62;iter_nth_child  = custom_list_iter_nth_child;
  iface-&#62;iter_parent     = custom_list_iter_parent;
}
</PRE
></TD
></TR
></TABLE
><P
>&#13;In <TT
CLASS="literal"
>custom_list_init</TT
> we initialised the custom
list structure to sensible default values. This function will be
called whenever a new instance of our custom list is created, which
we do in <TT
CLASS="literal"
>custom_list_new</TT
>.
</P
><P
>&#13;<TT
CLASS="literal"
>custom_list_finalize</TT
> is called just before one
of our lists is going to be destroyed. You should free all resources
that you have dynamically allocated in there.
</P
><P
>&#13;Having taken care of all the type system stuff, we now come to the heart of our custom model,
namely the tree model implementation. Our tree model functions need to behave exactly as the
API reference requires them to behave, including all special cases, otherwise things will not
work. Here is a list of links to the API reference descriptions of the functions we are
implementing:
</P
><P
></P
><UL
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-flags"
TARGET="_top"
>gtk_tree_model_get_flags</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-n-columns"
TARGET="_top"
>gtk_tree_model_get_n_columns</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-column-type"
TARGET="_top"
>gtk_tree_model_get_column_type</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-iter"
TARGET="_top"
>gtk_tree_model_get_iter</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-path"
TARGET="_top"
>gtk_tree_model_get_path</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-value"
TARGET="_top"
>gtk_tree_model_get_value</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-next"
TARGET="_top"
>gtk_tree_model_iter_next</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-children"
TARGET="_top"
>gtk_tree_model_iter_children</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-has-child"
TARGET="_top"
>gtk_tree_model_iter_has_child</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-n-children"
TARGET="_top"
>gtk_tree_model_iter_n_children</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-nth-child"
TARGET="_top"
>gtk_tree_model_iter_nth_child</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-parent"
TARGET="_top"
>gtk_tree_model_iter_parent</A
></P
></LI
></UL
><P
>&#13;Almost all functions are more or less straight-forward and self-explanatory
in connection with the API reference descriptions, so you should be able to
jump right into <A
HREF="sec-custom-model-code.html#sec-custom-model-code-body"
>the code</A
>
and see how it works.
</P
><P
>&#13;After the tree model implementation we have those functions that are specific to our
custom model. <TT
CLASS="literal"
>custom_list_new</TT
> will create a new custom list for us,
and <TT
CLASS="literal"
>custom_list_append_record</TT
> will append a new record to the end
of the list. Note the call to <TT
CLASS="literal"
>gtk_tree_model_row_inserted</TT
> at the
end of our append function, which emits a <TT
CLASS="literal"
>"row-inserted"</TT
>
signal on the model and informs all interested objects (tree views, tree row references)
that a new row has been inserted, and where it has been inserted.
</P
><P
>&#13;You will need to emit tree model signals whenever something changes, e.g. rows are inserted,
removed, or reordered, or when a row changes from a child-less row to a row which has children,
or if a row's data changes. Here are the functions you need to use in those cases (we only
implement row insertions here - other cases are left as an exercise for the reader):
</P
><P
></P
><UL
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-row-inserted"
TARGET="_top"
>gtk_tree_model_row_inserted</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-row-changed"
TARGET="_top"
>gtk_tree_model_row_changed</A
> (makes tree view redraw that row)</P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-row-has-child-toggled"
TARGET="_top"
>gtk_tree_model_row_has_child_toggled</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-row-deleted"
TARGET="_top"
>gtk_tree_model_row_deleted</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-rows-reordered"
TARGET="_top"
>gtk_tree_model_rows_reordered</A
>
     (note <A
HREF="http://bugs.gnome.org/show_bug.cgi?id=124790"
TARGET="_top"
>bug 124790</A
>)</P
></LI
></UL
><P
>&#13;And that is all you have to do to write a custom model.
</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="95%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="95%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sec-custom-models-what.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="treeview-tutorial.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sec-custom-model-tree.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>What Does Writing a Custom Model Involve?</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sec-custom-models.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>From a List to a Tree</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>