<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>GtkTreeModels for Data Storage: GtkListStore and GtkTreeStore</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="GTK+ 2.0 Tree View Tutorial"
HREF="treeview-tutorial.html"><LINK
REL="PREVIOUS"
TITLE="Components: Model, Renderer, Column, View"
HREF="sec-treeview-components.html"><LINK
REL="NEXT"
TITLE="Refering to Rows: GtkTreeIter, GtkTreePath, GtkTreeRowReference"
HREF="sec-treemodel-rowref.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./treeview-tutorial.css"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="95%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GTK+ 2.0 Tree View Tutorial</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sec-treeview-components.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sec-treemodel-rowref.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="95%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="sec-treemodels"
></A
>Chapter 3. GtkTreeModels for Data Storage: GtkListStore and GtkTreeStore</H1
><P
>&#13;It is important to realise what <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html"
TARGET="_top"
><TT
CLASS="literal"
>GtkTreeModel</TT
></A
>
is and what it is not. <TT
CLASS="literal"
>GtkTreeModel</TT
> is basically just an 'interface' to the data store,
meaning that it is a standardised set of functions that allows a <TT
CLASS="literal"
>GtkTreeView</TT
> widget
(and the application programmer) to query certain characteristics of a data store,
for example how many rows there are, which rows have children, and how many children a particular row has.
It also provides functions to retrieve data from the data store, and tell the tree view what type of data
is stored in the model. Every data store must implement the <TT
CLASS="literal"
>GtkTreeModel</TT
> interface and
provide these functions, which you can use by casting a store to a tree model with
<TT
CLASS="literal"
>GTK_TREE_MODEL(store)</TT
>. <TT
CLASS="literal"
>GtkTreeModel</TT
> itself only provides a way to
query a data store's characteristics and to retrieve existing data, it does not provide a way to remove
or add rows to the store or put data into the store. This is done using the specific store's functions.
</P
><P
>&#13;Gtk+ comes with two built-in data stores (models):
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkListStore.html"
TARGET="_top"
><TT
CLASS="literal"
>GtkListStore</TT
></A
> and
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeStore.html"
TARGET="_top"
><TT
CLASS="literal"
>GtkTreeStore</TT
></A
>.
As the names imply, <TT
CLASS="literal"
>GtkListStore</TT
> is used for simple lists of data items where items have
no hierarchical parent-child relationships, and <TT
CLASS="literal"
>GtkTreeStore</TT
> is used for tree-like data
structures, where items can have parent-child relationships. A list of files in a directory would be an example
of a simple list structure, whereas a directory tree is an example for a tree structure. A list is
basically just a special case of a tree with none of the items having any children, so one could use
a tree store to maintain a simple list of items as well. The only reason <TT
CLASS="literal"
>GtkListStore</TT
>
exists is in order to provide an easier interface that does not need to cater for child-parent relationships,
and because a simple list model can be optimised for the special case where no children exist, which makes
it faster and more efficient.
</P
><P
>&#13;<TT
CLASS="literal"
>GtkListStore</TT
> and <TT
CLASS="literal"
>GtkTreeStore</TT
> should cater for most types of data an
application developer might want to display in a <TT
CLASS="literal"
>GtkTreeView</TT
>. However, it should be noted
that <TT
CLASS="literal"
>GtkListStore</TT
> and <TT
CLASS="literal"
>GtkTreeStore</TT
> have been designed with flexibility in
mind. If you plan to store a lot of data, or have a large number of rows, you should consider implementing your own
custom model that stores and manipulates data your own way and implements the <TT
CLASS="literal"
>GtkTreeModel</TT
>
interface. This will not only be more efficient, but probably also lead to saner code in the long run, and give
you more control over your data. See <A
HREF="sec-custom-models.html"
>below</A
> for more details on how
to implement custom models.
</P
><P
>&#13;Tree model implementations like <TT
CLASS="literal"
>GtkListStore</TT
> and <TT
CLASS="literal"
>GtkTreeStore</TT
> will take
care of the view side for you once you have configured the <TT
CLASS="literal"
>GtkTreeView</TT
> to display what you
want. If you change data in the store, the model will notify the tree view and your data display will be
updated. If you add or remove rows, the model will also notify the store, and your row will appear in or
disappear from the view as well.
</P
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="sec-treemodel-data"
>3.1. How Data is Organised in a Store</A
></H1
><P
>&#13;A model (data store) has model columns and rows. While a tree view will display each row in the model as a row
in the view, the model's columns are not to be confused with a view's columns. A model column represents a certain
data field of an item that has a fixed data type. You need to know what kind of data you want to store when you
create a list store or a tree store, as you can not add new fields later on.
</P
><P
>&#13;For example, we might want to display a list of files. We would create a list store with two fields: a field
that stores the filename (ie. a string) and a field that stores the file size (ie. an unsigned integer).
The filename would be stored in column 0 of the model, and the file size would be stored in column 1 of the model.
For each file we would add a row to the list store, and set the row's fields to the filename and the file size.
</P
><P
>&#13;The <A
HREF="http://developer.gnome.org/doc/API/2.0/gobject/gobject-GType.html"
TARGET="_top"
>GLib type system (GType)</A
>
is used to indicate what type of data is stored in a model column. These are the most commonly used types:
</P
><P
></P
><UL
><LI
><P
>&#13;    <TT
CLASS="literal"
>G_TYPE_BOOLEAN</TT
>
  </P
></LI
><LI
><P
>&#13;    <TT
CLASS="literal"
>G_TYPE_INT</TT
>, <TT
CLASS="literal"
>G_TYPE_UINT</TT
>
  </P
></LI
><LI
><P
>&#13;    <TT
CLASS="literal"
>G_TYPE_LONG</TT
>, <TT
CLASS="literal"
>G_TYPE_ULONG</TT
>, <TT
CLASS="literal"
>G_TYPE_INT64</TT
>, <TT
CLASS="literal"
>G_TYPE_UINT64</TT
> (these are not supported in early gtk+-2.0.x versions)
  </P
></LI
><LI
><P
>&#13;    <TT
CLASS="literal"
>G_TYPE_FLOAT</TT
>, <TT
CLASS="literal"
>G_TYPE_DOUBLE</TT
>
  </P
></LI
><LI
><P
>&#13;    <TT
CLASS="literal"
>G_TYPE_STRING</TT
> - stores a string in the store (makes a copy of the original string)
  </P
></LI
><LI
><P
>&#13;    <TT
CLASS="literal"
>G_TYPE_POINTER</TT
> - stores a pointer value (does not copy any data into the store, just stores the pointer value!)
  </P
></LI
><LI
><P
>&#13;    <TT
CLASS="literal"
>GDK_TYPE_PIXBUF</TT
> - stores a GdkPixbuf in the store (increases the pixbuf's
    refcount, <A
HREF="sec-treemodel-storing-gobjects.html"
>see below</A
>)
  </P
></LI
></UL
><P
>&#13;You do not need to understand the type system, it will usually suffice to know the above types,
so you can tell a list store or tree store what kind of data you want to store. Advanced users can derive
their own types from the fundamental GLib types. For simple structures you could
<A
HREF="http://developer.gnome.org/doc/API/2.0/gobject/gobject-Boxed-Types.html#g-boxed-type-register-static"
TARGET="_top"
>register</A
>
a new <A
HREF="http://developer.gnome.org/doc/API/2.0/gobject/gobject-Boxed-Types.html"
TARGET="_top"
>boxed type</A
>
for example, but that is usually not necessary. <TT
CLASS="literal"
>G_TYPE_POINTER</TT
> will often do as well, you
will just need to take care of memory allocation and freeing yourself then.
</P
><P
>&#13;Storing <TT
CLASS="literal"
>GObject</TT
>-derived types (most <TT
CLASS="literal"
>GDK_TYPE_FOO</TT
>
and <TT
CLASS="literal"
>GTK_TYPE_FOO</TT
>) is a special case that is dealt with
<A
HREF="sec-treemodel-storing-gobjects.html"
>further below</A
>.
</P
><P
>&#13;Here is an example of how to create a list store:
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;  GtkListStore *list_store;

  list_store = gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_UINT);
</PRE
></TD
></TR
></TABLE
><P
>&#13;This creates a new list store with two columns. Column 0 stores a string and column 1 stores an unsigned integer for each row.
At this point the model has no rows yet of course. Before we start to add rows, let's have a look at the different ways used
to refer to a particular row.
</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="95%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="95%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sec-treeview-components.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="treeview-tutorial.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sec-treemodel-rowref.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Components: Model, Renderer, Column, View</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Refering to Rows: GtkTreeIter, GtkTreePath, GtkTreeRowReference</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>