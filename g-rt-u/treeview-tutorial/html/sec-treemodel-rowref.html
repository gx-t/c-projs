<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Refering to Rows: GtkTreeIter, GtkTreePath, GtkTreeRowReference</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="GTK+ 2.0 Tree View Tutorial"
HREF="treeview-tutorial.html"><LINK
REL="UP"
TITLE="GtkTreeModels for Data Storage: GtkListStore and GtkTreeStore"
HREF="sec-treemodels.html"><LINK
REL="PREVIOUS"
TITLE="GtkTreeModels for Data Storage: GtkListStore and GtkTreeStore"
HREF="sec-treemodels.html"><LINK
REL="NEXT"
TITLE="Adding Rows to a Store"
HREF="sec-treemodel-add-rows.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./treeview-tutorial.css"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="95%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GTK+ 2.0 Tree View Tutorial</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sec-treemodels.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. GtkTreeModels for Data Storage: GtkListStore and GtkTreeStore</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sec-treemodel-add-rows.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="95%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="sec-treemodel-rowref"
>3.2. Refering to Rows: GtkTreeIter, GtkTreePath, GtkTreeRowReference</A
></H1
><P
>&#13;There are different ways to refer to a specific row. The two you will have to deal with are
<TT
CLASS="literal"
>GtkTreeIter</TT
> and <TT
CLASS="literal"
>GtkTreePath</TT
>.
</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sec-treemodel-rowref-path"
>3.2.1. GtkTreePath</A
></H2
><FONT
COLOR="RED"
>Describing a row 'geographically'</FONT
><P
>&#13;A <TT
CLASS="literal"
>GtkTreePath</TT
> is a comparatively straight-forward way to describe the
logical position of a row in the model. As a <TT
CLASS="literal"
>GtkTreeView</TT
> always displays
<I
CLASS="emphasis"
>all</I
> rows in a model, a tree path always describes the same row in both model and view.
</P
><DIV
CLASS="figure"
><A
NAME="sec-treemodel-treepath-sshot"
></A
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="images/treepath.png"></P
></DIV
><P
><B
>Figure 3-1. Tree Paths</B
></P
></DIV
><P
>&#13;The picture shows the tree path in string form next to the label. Basically,
it just counts the children from the imaginary root of the tree view. An
empty tree path string would specify that imaginary invisible root. Now
'Songs' is the first child (from the root) and thus its tree path is just "0".
'Videos' is the second child from the root, and its tree path is "1". 'oggs'
is the second child of the first item from the root, so its tree path is "0:1".
So you just count your way down from the root to the row in question, and you
get your tree path.
</P
><P
>&#13;To clarify this, a tree path of "3:9:4:1" would basically mean
<I
CLASS="emphasis"
>in human language</I
> (attention - this is not what it really means!)
something along the lines of: go to the 3rd top-level row. Now go to the 9th child
of that row. Proceed to the 4th child of the previous row. Then continue to the
1st child of that. Now you are at the row this tree path describes.
This is not what it means for Gtk+ though. While humans start counting at 1, computers
usually start counting at 0. So the real meaning of the tree path "3:9:4:1" is: Go to the
4th top-level row. Then go to the 10th child of that row. Pick the 5th child of that row. Then
proceed to the 2nd child of the previous row. Now you are at the row this
tree path describes. :)
</P
><P
>&#13;The implication of this way of refering to rows is as follows: if you insert or delete
rows in the middle or if the rows are resorted, a tree path might suddenly refer to a
completely different row than it refered to before the insertion/deletion/resorting. This
is important to keep in mind.
(See the <A
HREF="sec-treemodel-rowref.html#sec-treemodel-rowref-rowref"
>section on
<TT
CLASS="literal"
>GtkTreeRowReference</TT
>s below</A
> for a tree path that keeps updating
itself to make sure it always refers to the same row when the model changes).
</P
><P
>&#13;This effect becomes apparent if you imagine what would happen if we were to delete the
row entitled 'funny clips' from the tree in the above picture. The row 'movie trailers' would
suddenly be the first and only child of 'clips', and be described by the tree path that
formerly belonged to 'funny clips', ie. "1:0:0".
</P
><P
>&#13;You can get a new <TT
CLASS="literal"
>GtkTreePath</TT
> from a
path in string form using <TT
CLASS="literal"
>gtk_tree_path_new_from_string</TT
>,
and you can convert a given <TT
CLASS="literal"
>GtkTreePath</TT
> into its string
notation with <TT
CLASS="literal"
>gtk_tree_path_to_string</TT
>. Usually you will
rarely have to handle the string notation, it is described here merely to
demonstrate the concept of tree paths.
</P
><P
>&#13;Instead of the string notation, <TT
CLASS="literal"
>GtkTreePath</TT
> uses an integer
array internally. You can get the depth (ie. the nesting level) of a tree path
with <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-path-get-depth"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_path_get_depth</TT
></A
>. A depth of 0 is the imaginary
invisible root node of the tree view and model. A depth of 1 means that the
tree path describes a top-level row. As lists are just trees without child nodes,
all rows in a list always have tree paths of depth 1.
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-path-get-indices"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_path_get_indices</TT
></A
> returns the internal integer
array of a tree path. You will rarely need to operate with those either.
</P
><P
>&#13;If you operate with tree paths, you are most likely to use a given tree path,
and use functions like
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk_tree_path_up"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_path_up</TT
></A
>,
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-path-down"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_path_down</TT
></A
>,
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-path-next"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_path_next</TT
></A
>,
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-path-prev"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_path_prev</TT
></A
>,
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-path-is-ancestor"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_path_is_ancestor</TT
></A
>, or
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-path-is-descendant"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_path_is_descendant</TT
></A
>.
Note that this way you can construct and operate on tree paths that refer to
rows that do not exist in model or view! The only way to check whether a
path is valid for a specific model (ie. the row described by the path exists)
is to convert the path into an iter using
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-iter"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_model_get_iter</TT
></A
>.
</P
><P
>&#13;<TT
CLASS="literal"
>GtkTreePath</TT
> is an opaque structure, with its details hidden from the compiler.
If you need to make a copy of a tree path, use
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-path-copy"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_path_copy</TT
></A
>.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sec-treemodel-rowref-iter"
>3.2.2. GtkTreeIter</A
></H2
><FONT
COLOR="RED"
>Refering to a row in model-speak</FONT
><P
>&#13;Another way to refer to a row in a list or tree is <TT
CLASS="literal"
>GtkTreeIter</TT
>. A tree iter is just a
structure that contains a couple of pointers that mean something to the model you are using. Tree iters are
used internally by models, and they often contain a direct pointer to the internal data of the row in question.
You should never look at the content of a tree iter and you must not modify it directly either.
</P
><P
>&#13;All tree models (and therefore also <TT
CLASS="literal"
>GtkListStore</TT
> and <TT
CLASS="literal"
>GtkTreeStore</TT
>)
must support the <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>GtkTreeModel</TT
></A
> functions that operate on tree iters (e.g. get
the tree iter for the first child of the row specified by a given tree iter, get the first row in the
list/tree, get the n-th child of a given iter etc.). Some of these functions are:
</P
><P
></P
><UL
><LI
><P
>&#13;   <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-iter-first"
TARGET="_top"
>&#13;   <TT
CLASS="literal"
>gtk_tree_model_get_iter_first</TT
></A
> - sets the given iter to the first top-level item in the list or tree
  </P
></LI
><LI
><P
>&#13;   <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-next"
TARGET="_top"
>&#13;   <TT
CLASS="literal"
>gtk_tree_model_iter_next</TT
></A
> - sets the given iter to the next item at the current level in a list or tree.
  </P
></LI
><LI
><P
>&#13;   <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-children"
TARGET="_top"
>&#13;   <TT
CLASS="literal"
>gtk_tree_model_iter_children</TT
></A
> - sets the first given iter to the first child of the row referenced by
     the second iter (not very useful for lists, mostly useful for trees).
  </P
></LI
><LI
><P
>&#13;   <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-n-children"
TARGET="_top"
>&#13;   <TT
CLASS="literal"
>gtk_tree_model_iter_n_children</TT
></A
> - returns the number of children the row referenced by the provided
     iter has. If you pass <TT
CLASS="literal"
>NULL</TT
> instead of a pointer to an iter structure, this function will return
     the number of top-level rows. You can also use this function to count the number of items in a list store.
  </P
></LI
><LI
><P
>&#13;   <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-nth-child"
TARGET="_top"
>&#13;   <TT
CLASS="literal"
>gtk_tree_model_iter_nth_child</TT
></A
> - sets the first iter to the n-th child of the row referenced
     by the second iter. If you pass <TT
CLASS="literal"
>NULL</TT
> instead of a pointer to an iter structure as the second
     iter, you can get the first iter set to the n-th row of a list.
  </P
></LI
><LI
><P
>&#13;   <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-parent"
TARGET="_top"
>&#13;   <TT
CLASS="literal"
>gtk_tree_model_iter_parent</TT
></A
> - sets the first iter to the parent of the row referenced by the
     second iter (does nothing for lists, only useful for trees).
  </P
></LI
></UL
><P
>&#13;Almost all of those functions return <TT
CLASS="literal"
>TRUE</TT
> if the requested operation succeeded, and
return <TT
CLASS="literal"
>FALSE</TT
> otherwise. There are more functions that operate on iters. Check out the
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>GtkTreeModel</TT
> API reference</A
> for details.
</P
><P
>&#13;You might notice that there is no <TT
CLASS="literal"
>gtk_tree_model_iter_prev</TT
>. This is unlikely to be
implemented for a variety of reasons. It should be fairly simple to write a helper function that provides
this functionality though once you have read this section.
</P
><P
>&#13;Tree iters are used to retrieve data from the store, and to put data into the store. You also get a tree iter
as result if you add a new row to the store using <TT
CLASS="literal"
>gtk_list_store_append</TT
> or
<TT
CLASS="literal"
>gtk_tree_store_append</TT
>.
</P
><P
>&#13;Tree iters are often only valid for a short time, and might become invalid if the store changes with some
models. It is therefore usually a bad idea to store tree iters, unless you really know what you are doing.
You can use <TT
CLASS="literal"
>gtk_tree_model_get_flags</TT
> to get a model's flags, and check whether the
<TT
CLASS="literal"
>GTK_TREE_MODEL_ITERS_PERSIST</TT
> flag is set (in which case a tree iter will be valid as
long as a row exists), yet still it is not advisable to store iter structures unless you really mean to
do that. There is a better way to keep track of a row over time: <TT
CLASS="literal"
>GtkTreeRowReference</TT
>
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sec-treemodel-rowref-rowref"
>3.2.3. GtkTreeRowReference</A
></H2
><FONT
COLOR="RED"
>Keeping track of rows even when the model changes</FONT
><P
>&#13;A <TT
CLASS="literal"
>GtkTreeRowReference</TT
> is basically an object that takes a tree path,
and watches a model for changes. If anything changes, like rows getting inserted or
removed, or rows getting re-ordered, the tree row reference object will keep the given
tree path up to date, so that it always points to the same row as before. In case the
given row is removed, the tree row reference will become invalid.
</P
><P
>&#13;A new tree row reference can be created with
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-row-reference-new"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_row_reference_new</TT
></A
>, given a model and a tree path. After
that, the tree row reference will keep updating the path whenever the model changes. The current
tree path of the row originally refered to when the tree row reference was created can be
retrieved with <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-row-reference-get-path"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_row_reference_get_path</TT
></A
>. If the row has been deleted,
<TT
CLASS="literal"
>NULL</TT
> will be returned instead of of a tree path. The tree path returned
is a <I
CLASS="emphasis"
>copy</I
>, so it will need to be freed with
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-path-free"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_path_free</TT
></A
> when it is no longer needed.
</P
><P
>&#13;You can check whether the row referenced still exists with
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-row-reference-valid"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_row_reference_valid</TT
></A
>, and free it with
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-row-reference-free"
TARGET="_top"
>&#13;<TT
CLASS="literal"
></TT
></A
> when no longer needed.
</P
><P
>&#13;For the curious: internally, the tree row reference connects to the tree model's
<TT
CLASS="literal"
>"row-inserted"</TT
>, <TT
CLASS="literal"
>"row-deleted"</TT
>, and
<TT
CLASS="literal"
>"rows-reordered"</TT
> signals and updates its internal tree path
whenever something happened to the model that affects the position of the
referenced row.
</P
><P
>&#13;Note that using tree row references entails a small overhead. This is hardly significant
for 99.9% of all applications out there, but when you have multiple thousands of rows
and/or row references, this might be something to keep in mind (because whenever rows are
inserted, removed, or reordered, a signal will be sent out and processed for each
row reference).
</P
><P
>&#13;If you have read the tutorial only up to here so far, it is hard to
explain really what tree row references are good for. An example
where tree row references come in handy can be found further below
in the <A
HREF="sec-treemodel-remove-many-rows.html"
>section on removing multiple rows in one go</A
>.
</P
><P
>&#13;In practice, a programmer can either use tree row references to keep track of rows over time,
or store tree iters directly (if, and only if, the model has persistent iters). Both
<TT
CLASS="literal"
>GtkListStore</TT
> and <TT
CLASS="literal"
>GtkTreeStore</TT
> have persistent iters,
so storing iters is possible. However, using tree row references is definitively the
Right Way(tm) to do things, even though it comes with some overhead that might impact
performance in case of trees that have a very large number of rows (in that
case it might be preferable to write a custom model anyway though). Especially beginners
might find it easier to handle and store tree row references than iters, because tree
row references are handled by pointer value, which you can easily add to a <TT
CLASS="literal"
>GList</TT
>
or pointer array, while it is easy to store tree iters in a wrong way.
</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sec-treemodel-rowref-usage"
>3.2.4. Usage</A
></H2
><P
>&#13;Tree iters can easily be converted into tree paths using
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-path"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_model_get_path</TT
></A
>, and tree
paths can easily be converted into tree iters using
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-iter"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_model_get_iter</TT
></A
>.
Here is an example that shows how to get the iter from the tree path that
is passed to us from the tree view in the <TT
CLASS="literal"
>"row-activated"</TT
>
signal callback. We need the iter here to retrieve data from the store
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;/************************************************************
 *                                                          *
 * Converting a GtkTreePath into a GtkTreeIter              *
 *                                                          *
 ************************************************************/

/************************************************************
 *
 * onTreeViewRowActivated: a row has been double-clicked
 *
 ************************************************************/

void
onTreeViewRowActivated (GtkTreeView *view, GtkTreePath *path,
                        GtkTreeViewColumn *col, gpointer userdata)
{
	GtkTreeIter   iter;
  GtkTreeModel *model;

  model = gtk_tree_view_get_model(view);

  if (gtk_tree_model_get_iter(model, &#38;iter, path))
  {
    gchar *name;

    gtk_tree_model_get(model, &#38;iter, COL_NAME, &#38;name, -1);

    g_print ("The row containing the name '%s' has been double-clicked.\n", name);

    g_free(name);
  }
}
</PRE
></TD
></TR
></TABLE
><P
>&#13;Tree row references
reveal the current path of a row with <TT
CLASS="literal"
>gtk_tree_row_reference_get_path</TT
>. There is no direct
way to get a tree iter from a tree row reference, you have to retrieve the tree row reference's path first and
then convert that into a tree iter.
</P
><P
>&#13;As tree iters are only valid for a short time, they are usually allocated on the stack, as in
the following example (keep in mind that <TT
CLASS="literal"
>GtkTreeIter</TT
> is just a structure
that contains data fields you do not need to know anything about):
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13; /************************************************************
  *                                                          *
  *  Going through every row in a list store                 *
  *                                                          *
  ************************************************************/

  void
  traverse_list_store (GtkListStore *liststore)
  {
    GtkTreeIter  iter;
    gboolean     valid;

    g_return_if_fail ( liststore != NULL );

    /* Get first row in list store */
    valid = gtk_tree_model_get_iter_first(GTK_TREE_MODEL(liststore), &#38;iter);

    while (valid)
    {
       /* ... do something with that row using the iter ...          */
       /* (Here column 0 of the list store is of type G_TYPE_STRING) */
       gtk_list_store_set(liststore, &#38;iter, 0, "Joe", -1);

       /* Make iter point to the next row in the list store */
       valid = gtk_tree_model_iter_next(GTK_TREE_MODEL(liststore), &#38;iter);
    }
  }
</PRE
></TD
></TR
></TABLE
><P
>&#13;The code above asks the model to fill the iter structure to make it point to the first
row in the list store. If there is a first row and the list store is not empty, the
iter will be set, and <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-get-iter-first"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_model_get_iter_first</TT
></A
> will return
<TT
CLASS="literal"
>TRUE</TT
>. If there is no first row, it will just return <TT
CLASS="literal"
>FALSE</TT
>.
If a first row exists, the while loop will be entered and we change some of the first
row's data. Then we ask the model to make the given iter point to the next row, until there
are no more rows, which is when <A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-iter-next"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_model_iter_next</TT
></A
> returns <TT
CLASS="literal"
>FALSE</TT
>.
Instead of traversing the list store we could also have used
<A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeModel.html#gtk-tree-model-foreach"
TARGET="_top"
>&#13;<TT
CLASS="literal"
>gtk_tree_model_foreach</TT
></A
>
</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="95%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="95%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sec-treemodels.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="treeview-tutorial.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sec-treemodel-add-rows.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>GtkTreeModels for Data Storage: GtkListStore and GtkTreeStore</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sec-treemodels.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Adding Rows to a Store</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>