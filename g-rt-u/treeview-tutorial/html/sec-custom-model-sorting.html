<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Additional interfaces, here: the GtkTreeSortable interface</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="GTK+ 2.0 Tree View Tutorial"
HREF="treeview-tutorial.html"><LINK
REL="UP"
TITLE="Writing Custom Models"
HREF="sec-custom-models.html"><LINK
REL="PREVIOUS"
TITLE="From a List to a Tree"
HREF="sec-custom-model-tree.html"><LINK
REL="NEXT"
TITLE="Working Example: Custom List Model Source Code"
HREF="sec-custom-model-code.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./treeview-tutorial.css"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="95%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GTK+ 2.0 Tree View Tutorial</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sec-custom-model-tree.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 11. Writing Custom Models</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sec-custom-model-code.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="95%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="sec-custom-model-sorting"
>11.5. Additional interfaces, here: the GtkTreeSortable interface</A
></H1
><P
>&#13;A custom model can implement additional interfaces to extend its functionality.
Additional interfaces are:
</P
><P
></P
><UL
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/GtkTreeSortable.html#GtkTreeSortableIface"
TARGET="_top"
>GtkTreeSortableIface</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/gtk-GtkTreeView-drag-and-drop.html#GtkTreeDragDestIface"
TARGET="_top"
>GtkTreeDragDestIface</A
></P
></LI
><LI
><P
><A
HREF="http://developer.gnome.org/doc/API/2.0/gtk/gtk-GtkTreeView-drag-and-drop.html#GtkTreeDragSourceIface"
TARGET="_top"
>GtkTreeDragSourceIface</A
></P
></LI
></UL
><P
>&#13;Here, we will show how to implement additional interfaces at the example of the
<TT
CLASS="literal"
>GtkTreeSortable</TT
> interface, which we will implement only partially
(enough to make it functional and useful though).
</P
><P
>&#13;Three things are necessary to add another interface: we will need to register the interface
with our model in <TT
CLASS="literal"
>custom_list_get_type</TT
>, provide an interface init function
where we set the interface to our own implementation of the interface functions,
and then provide the implementation of those functions.
</P
><P
>&#13;Firstly, we need to provide the function prototypes for our functions at the beginning of
the file:
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;
  /* custom-list.c */

  ...

  /* -- GtkTreeSortable interface functions -- */

  static gboolean     custom_list_sortable_get_sort_column_id (GtkTreeSortable *sortable,
                                                               gint            *sort_col_id,
                                                               GtkSortType     *order);

  static void         custom_list_sortable_set_sort_column_id (GtkTreeSortable *sortable,
                                                               gint             sort_col_id,
                                                               GtkSortType      order);

  static void         custom_list_sortable_set_sort_func (GtkTreeSortable        *sortable,
                                                          gint                    sort_col_id,
                                                          GtkTreeIterCompareFunc  sort_func,
                                                          gpointer                user_data,
                                                          GtkDestroyNotify        destroy_func);

  static void         custom_list_sortable_set_default_sort_func (GtkTreeSortable        *sortable,
                                                                  GtkTreeIterCompareFunc  sort_func,
                                                                  gpointer                user_data,
                                                                  GtkDestroyNotify        destroy_func);

  static gboolean     custom_list_sortable_has_default_sort_func (GtkTreeSortable *sortable);

  static void         custom_list_resort (CustomList *custom_list);

  ...
</PRE
></TD
></TR
></TABLE
><P
>&#13;Next, let's extend our <TT
CLASS="literal"
>CustomList</TT
> structure with a field for the currently active
sort column ID and one for the sort order, and add an enum for the sort column IDs:
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;  /* custom-list.h */

  enum
  {
    SORT_ID_NONE = 0,
    SORT_ID_NAME,
    SORT_ID_YEAR_BORN,
  };

  ...

  struct _CustomList
  {
    GObject         parent;

    guint           num_rows;    /* number of rows that we have */
    CustomRecord  **rows;        /* a dynamically allocated array of pointers to the
                                  *  CustomRecord structure for each row */

    gint            n_columns;
    GType           column_types[CUSTOM_LIST_N_COLUMNS];

    gint            sort_id;
    GtkSortType     sort_order;

    gint            stamp;       /* Random integer to check whether an iter belongs to our model */
  };

  ...
</PRE
></TD
></TR
></TABLE
><P
>&#13;Now, we make sure we initialise the new fields in <TT
CLASS="literal"
>custom_list_new</TT
>, and add our new
interface:
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;  ...

  static void    custom_list_sortable_init (GtkTreeSortableIface *iface);

  ...

  void
  custom_list_init (CustomList *custom_list)
  {
    ...
    custom_list-&#62;sort_id    = SORT_ID_NONE;
    custom_list-&#62;sort_order = GTK_SORT_ASCENDING;
    ...
  }


  GType
  custom_list_get_type (void)
  {
    ...
    /* Add GtkTreeSortable interface */
    if (1)
    {
      static const GInterfaceInfo tree_sortable_info =
      {
        (GInterfaceInitFunc) custom_list_sortable_init,
        NULL,
        NULL
      };

      g_type_add_interface_static (custom_list_type, GTK_TYPE_TREE_SORTABLE, &#38;tree_sortable_info);
    }
    ...
  }


  static void
  custom_list_sortable_init (GtkTreeSortableIface *iface)
  {
    iface-&#62;get_sort_column_id    = custom_list_sortable_get_sort_column_id;
    iface-&#62;set_sort_column_id    = custom_list_sortable_set_sort_column_id;
    iface-&#62;set_sort_func         = custom_list_sortable_set_sort_func;          /* NOT SUPPORTED */
    iface-&#62;set_default_sort_func = custom_list_sortable_set_default_sort_func;  /* NOT SUPPORTED */
    iface-&#62;has_default_sort_func = custom_list_sortable_has_default_sort_func;  /* NOT SUPPORTED */
  }

</PRE
></TD
></TR
></TABLE
><P
>&#13;Now that we have finally taken care of the administrativa, we implement the tree sortable interface functions:
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;
  static gboolean
  custom_list_sortable_get_sort_column_id (GtkTreeSortable *sortable,
                                           gint            *sort_col_id,
                                           GtkSortType     *order)
  {
    CustomList *custom_list;

    g_return_val_if_fail ( sortable != NULL        , FALSE );
    g_return_val_if_fail ( CUSTOM_IS_LIST(sortable), FALSE );

    custom_list = CUSTOM_LIST(sortable);

    if (sort_col_id)
      *sort_col_id = custom_list-&#62;sort_id;

    if (order)
      *order =  custom_list-&#62;sort_order;

    return TRUE;
  }


  static void
  custom_list_sortable_set_sort_column_id (GtkTreeSortable *sortable,
                                           gint             sort_col_id,
                                           GtkSortType      order)
  {
    CustomList *custom_list;

    g_return_if_fail ( sortable != NULL         );
    g_return_if_fail ( CUSTOM_IS_LIST(sortable) );

    custom_list = CUSTOM_LIST(sortable);

    if (custom_list-&#62;sort_id == sort_col_id &#38;&#38; custom_list-&#62;sort_order == order)
      return;

    custom_list-&#62;sort_id = sort_col_id;
    custom_list-&#62;sort_order  = order;

    custom_list_resort(custom_list);

    /* emit "sort-column-changed" signal to tell any tree views
     *  that the sort column has changed (so the little arrow
     *  in the column header of the sort column is drawn
     *  in the right column)                                     */

    gtk_tree_sortable_sort_column_changed(sortable);
  }


  static void
  custom_list_sortable_set_sort_func (GtkTreeSortable        *sortable,
                                      gint                    sort_col_id,
                                      GtkTreeIterCompareFunc  sort_func,
                                      gpointer                user_data,
                                      GtkDestroyNotify        destroy_func)
  {
    g_warning ("%s is not supported by the CustomList model.\n", __FUNCTION__);
  }


  static void
  custom_list_sortable_set_default_sort_func (GtkTreeSortable        *sortable,
                                              GtkTreeIterCompareFunc  sort_func,
                                              gpointer                user_data,
                                              GtkDestroyNotify        destroy_func)
  {
    g_warning ("%s is not supported by the CustomList model.\n", __FUNCTION__);
  }


  static gboolean
  custom_list_sortable_has_default_sort_func (GtkTreeSortable *sortable)
  {
    return FALSE;
  }

</PRE
></TD
></TR
></TABLE
><P
>&#13;Now, last but not least, the only thing missing is the function that does the actual
sorting. We do not implement <TT
CLASS="literal"
>set_sort_func</TT
>, <TT
CLASS="literal"
>set_default_sort_func</TT
>
and <TT
CLASS="literal"
>set_has_default_sort_func</TT
> because we use our own internal sort function here.
</P
><P
>&#13;The actual sorting is done using GLib's <TT
CLASS="literal"
>g_qsort_with_data</TT
> function, which sorts an
array using the QuickSort algorithm. Note how we notify the tree view and other objects of the new
row order by emitting the "rows-reordered" signal on the tree model.
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;
  static gint
  custom_list_compare_records (gint sort_id, CustomRecord *a, CustomRecord *b)
  {
    switch(sort_id)
    {
      case SORT_ID_NONE:
        return 0;

      case SORT_ID_NAME:
      {
        if ((a-&#62;name) &#38;&#38; (b-&#62;name))
          return g_utf8_collate(a-&#62;name, b-&#62;name);

        if (a-&#62;name == b-&#62;name)
          return 0; /* both are NULL */
        else
          return (a-&#62;name == NULL) ? -1 : 1;
      }

      case SORT_ID_YEAR_BORN:
      {
        if (a-&#62;year_born == b-&#62;year_born)
          return 0;

        return (a-&#62;year_born &#62; b-&#62;year_born) ? 1 : -1;
      }
    }

    g_return_val_if_reached(0);
  }


  static gint
  custom_list_qsort_compare_func (CustomRecord **a, CustomRecord **b, CustomList *custom_list)
  {
    gint ret;

    g_assert ((a) &#38;&#38; (b) &#38;&#38; (custom_list));

    ret = custom_list_compare_records(custom_list-&#62;sort_id, *a, *b);

    /* Swap -1 and 1 if sort order is reverse */
    if (ret != 0  &#38;&#38;  custom_list-&#62;sort_order == GTK_SORT_DESCENDING)
      ret = (ret &#60; 0) ? 1 : -1;

    return ret;
  }


  static void
  custom_list_resort (CustomList *custom_list)
  {
    GtkTreePath *path;
    gint        *neworder, i;

    g_return_if_fail ( custom_list != NULL );
    g_return_if_fail ( CUSTOM_IS_LIST(custom_list) );

    if (custom_list-&#62;sort_id == SORT_ID_NONE)
      return;

    if (custom_list-&#62;num_rows == 0)
      return;

    /* resort */
    g_qsort_with_data(custom_list-&#62;rows,
                      custom_list-&#62;num_rows,
                      sizeof(CustomRecord*),
                      (GCompareDataFunc) custom_list_qsort_compare_func,
                      custom_list);

    /* let other objects know about the new order */
    neworder = g_new0(gint, custom_list-&#62;num_rows);

    for (i = 0; i &#60; custom_list-&#62;num_rows; ++i)
    {
      /* Note that the API reference might be wrong about
       * this, see bug number 124790 on bugs.gnome.org.
       * Both will work, but one will give you 'jumpy'
       * selections after row reordering. */
      /* neworder[(custom_list-&#62;rows[i])-&#62;pos] = i; */
      neworder[i] = (custom_list-&#62;rows[i])-&#62;pos;
      (custom_list-&#62;rows[i])-&#62;pos = i;
    }

    path = gtk_tree_path_new();

    gtk_tree_model_rows_reordered(GTK_TREE_MODEL(custom_list), path, NULL, neworder);

    gtk_tree_path_free(path);
    g_free(neworder);
  }

</PRE
></TD
></TR
></TABLE
><P
>&#13;Finally, we should make sure that the model is resorted after we have inserted
a new row by adding a call to <TT
CLASS="literal"
>custom_list_resort</TT
> to the end
of <TT
CLASS="literal"
>custom_list_append</TT
>:
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;  ...
  void
  custom_list_append_record (CustomList *custom_list, const gchar *name, guint year_born)
  {
    ...

    custom_list_resort(custom_list);
  }

</PRE
></TD
></TR
></TABLE
><P
>&#13;And that is it. Adding two calls to <TT
CLASS="literal"
>gtk_tree_view_column_set_sort_column_id</TT
> in main.c
is left as yet another exercise for the reader.
</P
><P
>&#13;If you are interested in seeing string sorting speed issues in action, you should modify main.c like this:
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;  GtkWidget *
  create_view_and_model (void)
  {
    gint i;
    ...
    for (i=0; i &#60; 1000; ++i)
    {
      fill_model(customlist);
    }
    ...
  }
</PRE
></TD
></TR
></TABLE
><P
>&#13;Most likely, sorting 24000 rows by name will take up to several seconds now. Now, if you go back to
<TT
CLASS="literal"
>custom_list_compare_records</TT
> and replace the call to <TT
CLASS="literal"
>g_utf8_collate</TT
> with:
</P
><TABLE
BORDER="0"
BGCOLOR="#e3e3c4"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;  static gint
  custom_list_compare_records (gint sort_id, CustomRecord *a, CustomRecord *b)
  {
    ...

    if ((a-&#62;name) &#38;&#38; (b-&#62;name))
      return strcmp(a-&#62;name_collate_key,b-&#62;name_collate_key);

    ...
  }
</PRE
></TD
></TR
></TABLE
><P
>&#13;... then you should hopefully register a dramatic speed increase when sorting by name.
</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="95%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="95%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sec-custom-model-tree.html"
ACCESSKEY="P"
>&#60;&#60;&#60; Previous</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="treeview-tutorial.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sec-custom-model-code.html"
ACCESSKEY="N"
>Next &#62;&#62;&#62;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>From a List to a Tree</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sec-custom-models.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Working Example: Custom List Model Source Code</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>